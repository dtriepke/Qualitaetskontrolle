---
title: "Uebungsaufgaben statistische Qualitaetskontrolle"
output:
  html_notebook: default
  html_document: default
runtime: shiny
---

```{r, include=FALSE}
library(dplyr)
library(knitr)
library(plotly)
```


# Funktionen
```{r}
rm(list = ls(all = TRUE))

C_p_func <- function(go, gu, sd){ (go - gu) / (6 * sd) }
C_pk_func <- function(go, gu, sd, mu){ min( (go - mu)/(3*sd), (mu - gu)/(3*sd) )}

C_conf_func <- function(n, alpha, C, centered = TRUE, print = TRUE){
  if(centered){
  UG <- C * sqrt( qchisq(alpha/2, df = n -1) / (n - 1) ) 
  OB <- C * sqrt( qchisq(1- alpha/2, df = n -1) / (n - 1) ) 
  
  if(print){  cat("UG = ", UG, "\t", "OB = ", OB) }
  return(list(UG = UG, OG = OB))
  }
  else{
  UG <- C * (1 - qnorm( 1 - alpha/2) * sqrt( 1 / (9 * n * C^2) + 1 / (2 * n - 2) ))
  OB <- C * (1 + qnorm( 1 - alpha/2) * sqrt( 1 / (9 * n * C^2) + 1 / (2 * n - 2) ))
  
  if(print){  cat("UG = ", UG, "\t", "OB = ", OB) }
  return(list(UG = UG, OG = OB))
  }
}
```


```{r}
tmp <- C_conf_func(n = 20, alpha = 0.05, C = 1.2579, centered = TRUE)
```


# Aufgabe 1

```{r}
n <- 40 
Xbar <- 10.01
S <- 0.02
gu <- 9.9
go <- 10.1
alpha <- 0.05
```
**Prozessfaehigkeitsindex $\hat{C}_p$**
```{r}
C_p <- C_p_func(go= go, gu = gu, sd = S)
paste("C_p = ", round(C_p,2))
```
**Konfidenzintervall**
```{r}
error <- qnorm(1-alpha/2) * S / sqrt(n)
Wu <-  Xbar - error
Wo <- Xbar + error
paste(c("Wu = ", "Wo = "),c( round(Wu, 2), round(Wo, 2)) )
```

***

# Aufgabe 2
## (a) $\bar{X}$ - Karte: *"Laenge von Nieten"*

```{r}
n <- 20
Xbar <- 20.08
S <- 0.053
gu <- 19.8
go <- 20.2
```

**Prozessfaehigkeitsindex $\hat{C}_p$**
```{r}
C_p <- C_p_func(go = go, gu = gu, sd = S)
paste("C_p = ", round(C_p,2))
C_p_conf <- C_conf_func(n = n, alpha = alpha, C = C_p, centered = TRUE)
```


**Prozessfaehigkeitsindex $\hat{C}_{pk}$**
```{r}
C_pk <- C_pk_func(go = go, gu <- gu, sd = S, mu <- Xbar)
paste("C_pk = ", round(C_pk,2))
C_pk_conf <- C_conf_func(n = n, alpha = alpha, C = C_pk, centered = FALSE)
```



## (b) u - Karte / p - Karte: *"Fehler in produzierten Stoffballen"*

Produzierte Stoffballen werden hinsichtlich der Fehlerzahl ueberwacht. Als u0 wird nach Voruntersuchungen 0.25 angesetzt. 
Außerdem sei w = 1.64485 und κ = 2.78215.
Es wird die u - Karte mit der p -Karte verglichen um die Prozesskonsistenz zu validieren.  

> Aus der Tabelle erkennt man, dass der Prozess bei beiden Karten im achten Los außer Kontrolle ist. 

```{r}
u0 <- 0.25
w <- qnorm(0.95)
k <- qnorm(0.9973)
los_data <- data.frame(X_i = c(4,3,11,1,3,9,4,13,5,1),
                       m_i = c(20,18,24,14,19,29,21,15,18,22))

los_data <- los_data %>% mutate(
   # u - Karte
  u_i =  X_i / m_i,
  Wo_u = u0 + w * sqrt(u0 /m_i),
  Ko_u = u0 + k * sqrt(u0 /m_i),
  Check_u = ifelse(u_i > Ko_u, "ausßer Kontrolle", ifelse(u_i > Wo_u, "Warnung", "")) ,
  # p - Karte
  Wo_p = u0 + w * sqrt(u0 * (1 - u0) / m_i),
  Ko_p = u0 + k * sqrt(u0 * (1 - u0) / m_i),
  Check_p = ifelse(u_i > Ko_p, "ausßer Kontrolle", ifelse(u_i > Wo_p, "Warnung", ""))
  
)

kable(los_data, format = "markdown", digits = 2, row.names = nrow(los_data))

```


In dem nachfolgenden Grafen ist der Prozessverlauf der 10 Lose und die oberen Warn- und Kontrollgrenzen der u - Karte und der p - Karte dargestellt.

```{r, fig.height=8}
Wo_u_fun <- stepfun( 1:9 + 0.5, los_data$Wo_u, f = 0)
Ko_u_fun <- stepfun(1:9 + 0.5, los_data$Ko_u, f = 0)
Wo_p_fun <- stepfun(1:9 + 0.5, los_data$Wo_p, f = 0)
Ko_p_fun <- stepfun(1:9 + 0.5, los_data$Ko_p, f = 0)


plot(Wo_u_fun, 
     lty = 4, 
     lwd = 2, 
     col = "blue",
     axes = FALSE,
     ylim = c(0:1),
     xlab = "Charge", 
     ylab = expression(X[i] / m[i]), 
     main = "")

par(new=TRUE)
plot(Ko_u_fun, 
     lty = 2, 
     lwd = 2,
     col = "blue",
     axes = FALSE, 
     ylim = c(0:1),
     xlab="", 
     ylab="", 
     main = "")

par(new=TRUE)
plot(Wo_p_fun, 
     lty = 4, 
     lwd = 2,
     col = "purple",
     axes = FALSE, 
     ylim = c(0:1),
     xlab="", 
     ylab="", 
     main = "")

par(new=TRUE)
plot(Ko_p_fun, 
     lty = 2, 
     lwd = 2,
     col = "purple",
     axes = FALSE, 
     ylim = c(0:1),
     xlab="", 
     ylab="", 
     main = "")


lines(x = 1:10, y = los_data$u_i, type ="o")
abline(h = u0, col = "green", lwd = 2 )

axis(1, 0:10.5)
axis(2, seq(0,1, by = 0.1))

legend("topright", c("Prozess","u - Karte", "p - Karte", expression(u[0])), lty = c(1,1,1,1), col = c("black","blue", "purple", "green"), lwd = c(1,2,2,2))
	
```


#Aufgabe 3
Bestimmen der Operationscharaczeristrik eines einfachen Prüfplans mit 

* *N* = 1000  
* *c* = 4  
* *n* = 100

```{r}
N <- 1000
c <- 4
n <- 100
```

**Operationscharacteristik L(p)**

```{r}
L_p_func <- function(N, n, c, p, print = TRUE){
  
  # PART: sanity check part------
  stopifnot(p <= 1 & p >= 0 ) # check whether p is element (0,1)
  for (x in c(N,n,c)){
    # N, n, c must be a integer/ double
    stopifnot(abs(x - round(x)) < .Machine$double.eps^0.5)
  }
  
  # PART: claculation --------
  p_range <- p # p can be a scalar or a set
  L <- 0 # forst entry is abitrarly number and will be removed after loop
  
  # forst loop takes the stated subspace od the definition range
  for (p in p_range){
    # calc M regarding p = M/N
    M <- round(p*N, 0)
    
    # second loop calc a for a given p the operation characteristic
    tmp <- 0 # temporary storage
    for ( i in c(0:c)){
      tmp <- tmp + dhyper(i, M, N - M, n)
    } 
    L <- c(L, tmp) # storage the result for L in a vector
  }
  
  # PART: output settings -----
  output <- list(L = L[-1], p = p_range) 
  if(print){cat(paste0("L(",p_range,") = ", paste0(round(output$L,5), ";  ") ))}
  return(output)
}

```


**Test**

```{r}
L_p <- L_p_func(N = 100, n = 10, c = 3, p = seq(0,1, by = 0.1), print = TRUE)

plot_ly(x = L_p$p, y = L_p$L, type = "scatter", mode = "lines") %>% 
  layout(xaxis = list(title = "p"),
         yaxis = list(title = "L(P)"))

```


**Algorithmus von Guenther**

```{r}
find_n_c <- function(n = 1, c = 0, 
                     alpha, 
                     AQL, # p_{1- alpha}
                     beta, 
                     RQL, # p_{beta}
                     N){

  `1-alpha` <- 1 - alpha
  L_AQL <- L_p_func(N = N, n = n, c = c, p = AQL, print = FALSE)
  L_RQL <- L_p_func(N = N, n = n, c = c, p = RQL, print = FALSE)
  
  if(L_AQL$L >= `1-alpha` & L_RQL$L <= beta){
    return(list(n = n, c = c))
  }
  
  while(L_RQL$L > beta){
    n <- n + 1
    L_RQL <- L_p_func(N = N, n = n, c = c, p = RQL, print = FALSE)
  }

  L_AQL <- L_p_func(N = N, n = n, c = c, p = AQL, print = FALSE)
  
  
  if(L_AQL$L >= `1-alpha`){
     return(list(n = n, c = c))
  }
  
  c <- c + 1
  find_n_c(n = n, c = c, alpha, AQL, beta, RQL, N)
  
} 

```

**Test**
```{r}
find_n_c(n = 1, c = 0, alpha  = 0.05, AQL = 0.01, beta = 0.1, RQL = 0.04, N = 400)

```




```{r, fig.height=15}
library(shiny)


ui <- fluidPage(
  headerPanel("Operations Charakteristic for Hyp() with Guenther's Algorithmus", windowTitle = "Operations Charakteristic for Hyp()"),
  titlePanel("Control Pannel"),
  sidebarLayout(
    sidebarPanel(
      sliderInput(inputId = "one_min_alpha", label = "1 - alpha",
                  value = 1, min = 0, max = 1),
      sliderInput(inputId = "AQL", label = "AQL",
                  value = 1, min = 0, max = 1),
      sliderInput(inputId = "beta", label = "beta",
                  value = 1, min = 0, max = 1),
      sliderInput(inputId = "RQL", label = "RQL",
                  value = 1, min = 0, max = 1),
      numericInput(inputId = "N", label = "N",
                   value = 400, min = 1, max = 5000),
      actionButton("action", label = "find optimal plan")
    ),
    mainPanel(
      plotlyOutput("plot"),
      h3(textOutput("text"))
      
    )
  )
)

server <- function(input, output) {
  
  # # renderPlotly() also understands ggplot2 objects!
  output$plot <- renderPlotly({
    input$action
    tmp <- isolate(find_n_c(n = 1, c = 0, alpha  = 1 - input$one_min_alpha, AQL = input$AQL, beta = input$beta, RQL = input$RQL, N = input$N))
    L_p <- isolate(L_p_func(N = input$N, n = tmp$n, c = tmp$c, p = seq(0,1, by = 0.01), print = FALSE))
    
    isolate(plot_ly(x = L_p$p, y = L_p$L, type = "scatter", mode = "lines", name = "L(p)") %>% 
      layout(xaxis = list(title = "p"),
             yaxis = list(title = "L(P)")) %>% 
      add_trace(x = c(input$AQL, input$AQL), y = c(0,1), type = "scatter", mode = "lines", name = "AQL") %>% 
      add_trace(x = c(input$RQL, input$RQL), y = c(0,1), type = "scatter", mode = "lines", name = "RQL") %>% 
      add_trace(x = c(input$AQL), y = c(input$one_min_alpha), type = "scatter", mode = "markers", name = "RQL") %>% 
      add_trace(x = c(input$RQL), y = c(input$beta), type = "scatter", mode = "markers", name = "RQL"))
  })
  
  output$text <- renderPrint({
    
    input$action
    tmp <- isolate(find_n_c(n = 1, c = 0, alpha  = 1 - input$one_min_alpha, AQL = input$AQL, beta = input$beta, RQL = input$RQL, N = input$N))
    cat("optimal plan: ", "n* = ", tmp$n,"\t", "c* = ", tmp$c)
  })
  
  
  
}

shinyApp(ui, server)
```










